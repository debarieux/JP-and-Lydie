import React, { useState, useEffect, useRef } from 'react';
import './App.css';
import PhotoCard from './PhotoCard';
import { Photo } from './types';

function App() {
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');
  const [currentView, setCurrentView] = useState<'upload' | 'login' | 'gallery'>('upload');
  const [showPasswordChange, setShowPasswordChange] = useState(false);
  const [newPassword, setNewPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [currentPassword, setCurrentPassword] = useState('');
  const [isAuthenticated, setIsAuthenticated] = useState(() => {
    const saved = localStorage.getItem('isAuthenticated');
    return saved === 'true';
  });

  const correctPassword = 'Jean-Philippe & Lydie';

  const [photos, setPhotos] = useState<Photo[]>([]);
  const [loading, setLoading] = useState(false); // Initialiser √† false

  const [zoomPhoto, setZoomPhoto] = useState<Photo | null>(null);
  const [notification, setNotification] = useState<{ message: string; type: 'success' | 'error' } | null>(null);
  const [uploadedFiles, setUploadedFiles] = useState<File[]>([]);
  const [isUploading, setIsUploading] = useState(false);
  const [isRefreshing, setIsRefreshing] = useState(false);
  const fileInputRef = useRef<HTMLInputElement>(null);

  // Fonction pour charger les photos depuis l'API
  const fetchPhotos = async () => {
    try {
      setLoading(true);
      setIsRefreshing(true);
      console.log('üîÑ Chargement des photos depuis l\'API...');
      
      // Timeout pour √©viter les blocages
      const timeoutPromise = new Promise((_, reject) => {
        setTimeout(() => reject(new Error('Timeout lors du chargement des photos')), 10000);
      });
      
      const fetchPromise = fetch('/api/photos');
      const response = await Promise.race([fetchPromise, timeoutPromise]) as Response;
      
      console.log('üì° R√©ponse API photos:', response.status);
      
      if (response.ok) {
        const photosData = await response.json();
        console.log('üì∏ Photos re√ßues:', photosData);
        console.log('üìä Nombre de photos:', photosData.length);
        
        // Utiliser directement les URLs ImageKit sans cache-busting
        photosData.forEach((photo: Photo, index: number) => {
          console.log(`üì∑ Photo ${index + 1}:`, photo);
          console.log(`üîó URL ImageKit: ${photo.url}`);
        });
        
        console.log('üì∏ Photos pr√™tes pour affichage:', photosData);
        setPhotos(photosData);
        console.log('‚úÖ Photos charg√©es avec succ√®s dans l\'√©tat');
      } else {
        console.error('‚ùå Erreur lors du chargement des photos:', response.status);
        showNotification('Erreur lors du chargement de la galerie', 'error');
      }
    } catch (error) {
      console.error('‚ùå Erreur lors du chargement des photos:', error);
      showNotification('Erreur lors du chargement de la galerie', 'error');
    } finally {
      setLoading(false);
      setIsRefreshing(false);
    }
  };

  // Charger les photos depuis l'API au montage
  useEffect(() => {
    if (isAuthenticated && currentView === 'gallery') {
      fetchPhotos();
    } else {
      // Si pas authentifi√©, s'assurer que loading est false
      setLoading(false);
    }
  }, [isAuthenticated, currentView]);

  // Rafra√Æchissement intelligent : seulement quand n√©cessaire
  useEffect(() => {
    if (!isAuthenticated || currentView !== 'gallery') return;
    
    const interval = setInterval(() => {
      // Rafra√Æchir seulement si on n'a pas fait d'action r√©cemment
      const lastActionTime = localStorage.getItem('lastActionTime');
      const now = Date.now();
      const timeSinceLastAction = lastActionTime ? now - parseInt(lastActionTime) : 60000; // 1 minute par d√©faut
      
      if (timeSinceLastAction > 30000) { // Rafra√Æchir seulement si plus de 30s depuis la derni√®re action
        console.log('üîÑ Rafra√Æchissement automatique intelligent...');
        fetchPhotos();
      } else {
        console.log('‚è∏Ô∏è Rafra√Æchissement ignor√© (action r√©cente)');
      }
    }, 30000); // V√©rifier toutes les 30 secondes

    return () => clearInterval(interval);
  }, [isAuthenticated, currentView]);

  // Redirection bas√©e sur l'authentification
  useEffect(() => {
    if (isAuthenticated) {
      // Si authentifi√©, aller √† la galerie
      setCurrentView('gallery');
    } else {
      // Si pas authentifi√©, aller √† l'upload
      setCurrentView('upload');
    }
  }, [isAuthenticated]);

  const handleLogin = (e: React.FormEvent) => {
    e.preventDefault();
    if (password === correctPassword) {
      setIsAuthenticated(true);
      localStorage.setItem('isAuthenticated', 'true');
      setCurrentView('gallery');
      setError('');
    } else {
      setError('Code d\'acc√®s incorrect. Veuillez r√©essayer.');
    }
  };

  const handleLogout = () => {
    setIsAuthenticated(false);
    localStorage.removeItem('isAuthenticated');
    setCurrentView('upload');
    setPassword('');
    setError('');
  };

  const goToLogin = () => {
    setCurrentView('login');
    setPassword('');
    setError('');
  };

  const goToUpload = () => {
    setCurrentView('upload');
    setPassword('');
    setError('');
  };

  const handleZoom = (photo: Photo) => setZoomPhoto(photo);
  const handleCloseZoom = () => setZoomPhoto(null);

  // Fonction pour marquer une action (rafra√Æchissement intelligent)
  const markAction = () => {
    localStorage.setItem('lastActionTime', Date.now().toString());
  };

  const handleDelete = async (id: number) => {
    if (window.confirm('√ätes-vous s√ªr de vouloir supprimer cette photo ?')) {
      try {
        console.log('üóëÔ∏è Suppression de la photo:', id);
        const response = await fetch(`/api/photos?id=${id}`, {
          method: 'DELETE'
        });
        
        if (response.ok) {
          console.log('‚úÖ Photo supprim√©e avec succ√®s');
          markAction(); // Marquer l'action
          // Rafra√Æchissement imm√©diat
          await fetchPhotos();
          showNotification('Photo supprim√©e avec succ√®s', 'success');
          
          // Rafra√Æchissement suppl√©mentaire apr√®s 2 secondes
          setTimeout(async () => {
            console.log('üîÑ V√©rification post-suppression...');
            await fetchPhotos();
          }, 2000);
        } else {
          console.error('‚ùå Erreur lors de la suppression:', response.status);
          showNotification('Erreur lors de la suppression', 'error');
        }
      } catch (error) {
        console.error('‚ùå Erreur lors de la suppression:', error);
        showNotification('Erreur lors de la suppression', 'error');
      }
    }
  };

  const handleToggleFavorite = async (id: number) => {
    const photo = photos.find(p => p.id === id);
    if (!photo) {
      console.error('‚ùå Photo non trouv√©e pour l\'ID:', id);
      return;
    }

    try {
      console.log('‚≠ê Changement favori pour la photo:', id);
      console.log('üì∏ Photo actuelle:', photo);
      console.log('üîÑ Nouvel √©tat favori:', !photo.isFavorite);
      
      const response = await fetch(`/api/photos?id=${id}`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          isFavorite: !photo.isFavorite
        })
      });

      console.log('üì° R√©ponse API:', response.status, response.statusText);

      if (response.ok) {
        const updatedPhoto = await response.json();
        console.log('‚úÖ Photo mise √† jour:', updatedPhoto);
        
        markAction(); // Marquer l'action
        // Rafra√Æchissement imm√©diat
        await fetchPhotos();
        showNotification(
          photo.isFavorite ? 'Retir√© des favoris' : 'Ajout√© aux favoris', 
          'success'
        );
        
        // Rafra√Æchissement suppl√©mentaire apr√®s 2 secondes
        setTimeout(async () => {
          console.log('üîÑ V√©rification post-favori...');
          await fetchPhotos();
        }, 2000);
      } else {
        const errorText = await response.text();
        console.error('‚ùå Erreur lors de la mise √† jour:', response.status, errorText);
        showNotification('Erreur lors de la mise √† jour', 'error');
      }
    } catch (error) {
      console.error('‚ùå Erreur lors de la mise √† jour:', error);
      showNotification('Erreur lors de la mise √† jour', 'error');
    }
  };

  const showNotification = (message: string, type: 'success' | 'error') => {
    setNotification({ message, type });
    setTimeout(() => setNotification(null), 3000);
  };

  const handlePasswordChange = (e: React.FormEvent) => {
    e.preventDefault();
    
    if (currentPassword !== correctPassword) {
      showNotification('Mot de passe actuel incorrect', 'error');
      return;
    }
    
    if (newPassword !== confirmPassword) {
      showNotification('Les mots de passe ne correspondent pas', 'error');
      return;
    }
    if (newPassword.length < 6) {
      showNotification('Le mot de passe doit contenir au moins 6 caract√®res', 'error');
      return;
    }
    if (newPassword === currentPassword) {
      showNotification('Le nouveau mot de passe doit √™tre diff√©rent de l\'actuel', 'error');
      return;
    }
    
    showNotification('Mot de passe modifi√© avec succ√®s', 'success');
    setShowPasswordChange(false);
    setNewPassword('');
    setConfirmPassword('');
    setCurrentPassword('');
  };

  const handleFileUpload = (event: React.ChangeEvent<HTMLInputElement>) => {
    const files = Array.from(event.target.files || []);
    const imageFiles = files.filter(file => file.type.startsWith('image/'));
    
    if (imageFiles.length !== files.length) {
      showNotification('Seules les images sont accept√©es', 'error');
    }
    
    // Accepter tous les fichiers d'image, peu importe la taille
    setUploadedFiles(prev => [...prev, ...imageFiles]);
    
    // Vider l'input file pour permettre de s√©lectionner les m√™mes fichiers √† nouveau
    event.target.value = '';
  };

  // Gestion du drag & drop
  const handleDragOver = (event: React.DragEvent<HTMLDivElement>) => {
    event.preventDefault();
    event.stopPropagation();
    event.currentTarget.classList.add('drag-over');
  };

  const handleDragLeave = (event: React.DragEvent<HTMLDivElement>) => {
    event.preventDefault();
    event.stopPropagation();
    event.currentTarget.classList.remove('drag-over');
  };

  const handleDrop = (event: React.DragEvent<HTMLDivElement>) => {
    event.preventDefault();
    event.stopPropagation();
    event.currentTarget.classList.remove('drag-over');
    
    const files = Array.from(event.dataTransfer.files);
    const imageFiles = files.filter(file => file.type.startsWith('image/'));
    
    if (imageFiles.length !== files.length) {
      showNotification('Seules les images sont accept√©es', 'error');
    }
    
    if (imageFiles.length > 0) {
      setUploadedFiles(prev => [...prev, ...imageFiles]);
      showNotification(`${imageFiles.length} photo(s) ajout√©e(s) par glisser-d√©poser`, 'success');
      
      // Vider l'input file pour s'assurer qu'il soit r√©initialis√©
      if (fileInputRef.current) {
        fileInputRef.current.value = '';
      }
    }
  };

  const handleDragEnter = (event: React.DragEvent<HTMLDivElement>) => {
    event.preventDefault();
    event.stopPropagation();
  };

  const handleUploadSubmit = async () => {
    if (uploadedFiles.length === 0) {
      showNotification('Veuillez s√©lectionner au moins une photo', 'error');
      return;
    }

    setIsUploading(true);
    console.log('üîÑ D√©but du processus d\'upload...');
    console.log(`üì± Appareil: ${navigator.userAgent}`);
    
    // D√©tection appareil mobile r√©el
    const isRealMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
    const isSamsung = navigator.userAgent.includes('Samsung') || navigator.userAgent.includes('SM-');
    
    console.log(`üì± Appareil mobile r√©el: ${isRealMobile}`);
    console.log(`üì± Appareil tactile: ${isTouchDevice}`);
    console.log(`üì± Samsung: ${isSamsung}`);
    
    try {
      console.log('üöÄ D√©but de l\'upload de', uploadedFiles.length, 'photos');
      
      // Traiter les images une par une
      for (let i = 0; i < uploadedFiles.length; i++) {
        const file = uploadedFiles[i];
        console.log(`üì§ Upload photo ${i + 1}/${uploadedFiles.length}:`, file.name, `(${(file.size / 1024 / 1024).toFixed(1)}MB)`);
        
        try {
          // Utiliser directement le fichier sans compression pour l'instant
          const processedFile = file;
          console.log(`üì¶ Fichier pr√©par√©: ${processedFile.name} -> ${(processedFile.size / 1024 / 1024).toFixed(2)}MB`);
          
          // Pr√©paration des donn√©es avec FormData
          const formData = new FormData();
          formData.append('file', processedFile);
          
          console.log(`üì§ Envoi de ${processedFile.name} vers l'API upload...`);
          
          // Timeout de 15 secondes pour √©viter les blocages
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 15000);
          
          // Upload de l'image via l'API d'upload
          const uploadResponse = await fetch('/api/upload', {
            method: 'POST',
            body: formData,
            signal: controller.signal
          });
          
          clearTimeout(timeoutId);
          console.log(`üì° R√©ponse API upload pour ${processedFile.name}:`, uploadResponse.status, uploadResponse.statusText);
          
          if (!uploadResponse.ok) {
            const errorText = await uploadResponse.text();
            console.error(`‚ùå Erreur API upload pour ${processedFile.name}:`, errorText);
            throw new Error(`Erreur lors de l'upload de l'image: ${uploadResponse.status} - ${errorText}`);
          }
          
          const uploadResult = await uploadResponse.json();
          console.log(`‚úÖ Upload r√©ussi pour ${processedFile.name}:`, uploadResult);
          console.log(`üîó URL re√ßue: ${uploadResult.imageUrl}`);
          
          // Cr√©er la photo dans la galerie avec l'URL de l'image upload√©e
          const newPhoto = {
            url: uploadResult.imageUrl,
            title: `Photo upload√©e ${Date.now() + i}`,
            isFavorite: false
          };

          console.log(`üìù Envoi de la photo √† l'API photos:`, newPhoto);
          console.log(`üñºÔ∏è URL qui sera affich√©e: ${newPhoto.url}`);
          console.log(`üîç V√©rification URL: ${newPhoto.url}`);
          
          // Test de l'URL pour voir si elle est accessible
          try {
            const testResponse = await fetch(newPhoto.url, { method: 'HEAD' });
            console.log(`üîç Test URL ${newPhoto.url}: ${testResponse.status} ${testResponse.statusText}`);
          } catch (error) {
            console.error(`‚ùå URL non accessible: ${newPhoto.url}`, error);
          }

          const response = await fetch('/api/photos', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify(newPhoto)
          });

          console.log(`üì° R√©ponse API photos pour ${processedFile.name}:`, response.status, response.statusText);
          
          if (response.ok) {
            const createdPhoto = await response.json();
            console.log(`‚úÖ Photo cr√©√©e avec succ√®s:`, createdPhoto);
            console.log(`üÜî ID de la photo cr√©√©e: ${createdPhoto.id}`);
            console.log(`üîó URL finale: ${createdPhoto.url}`);
          } else {
            const errorText = await response.text();
            console.error(`‚ùå Erreur API photos pour ${processedFile.name}:`, errorText);
            throw new Error(`Erreur lors de l'ajout de la photo: ${response.status} - ${errorText}`);
          }
          
        } catch (error) {
          console.error(`‚ùå Erreur pour ${file.name}:`, error);
          
          if (error instanceof Error && error.name === 'AbortError') {
            throw new Error('L\'upload a pris trop de temps. Essayez avec une image plus petite.');
          } else {
            throw error;
          }
        }
      }
      
      console.log(`üéâ Toutes les ${uploadedFiles.length} photos upload√©es avec succ√®s !`);
      
      // Recharger la galerie apr√®s tous les uploads
      console.log('üîÑ Rechargement de la galerie...');
      await fetchPhotos();
      console.log('‚úÖ Galerie recharg√©e avec succ√®s');
      
      markAction(); // Marquer l'action d'upload
      
      // Nettoyer les fichiers upload√©s
      setUploadedFiles([]);
      
      // Vider l'input file pour s'assurer qu'il soit r√©initialis√©
      if (fileInputRef.current) {
        fileInputRef.current.value = '';
      }
      
      showNotification(`${uploadedFiles.length} photo(s) upload√©e(s) avec succ√®s !`, 'success');
      
    } catch (error) {
      console.error('‚ùå Erreur lors de l\'upload:', error);
      const errorMessage = error instanceof Error ? error.message : 'Erreur inconnue';
      showNotification(`Erreur lors de l'upload des photos: ${errorMessage}`, 'error');
    } finally {
      console.log('üèÅ Fin du processus d\'upload');
      setIsUploading(false);
    }
  };

  // Fonction pour supprimer un fichier de la liste d'upload
  const removeUploadedFile = (index: number) => {
    setUploadedFiles(prev => prev.filter((_, i) => i !== index));
  };

  // Page d'upload
  if (currentView === 'upload') {
    return (
      <div className="upload-page">
        <header className="main-header">
          <div className="main-header-content">
            <button onClick={goToLogin} className="main-connection-button">
              Connection
            </button>
          </div>
        </header>

        <main className="main-content">
          <div className="names-section">
            <div className="names-container">
              <h1 className="upload-title">Jean-Philippe</h1>
              <h1 className="upload-title">&</h1>
              <h1 className="upload-title">Lydie</h1>
            </div>
            <div className="separator"></div>
            <div className="thank-you-message">
              <p>Merci de partager votre tendresse et vos souvenirs pr√©cieux avec nous !</p>
            </div>
          </div>

          <div className="upload-section-container">
            <div 
              className="upload-area"
              onDragOver={handleDragOver}
              onDragLeave={handleDragLeave}
              onDrop={handleDrop}
              onDragEnter={handleDragEnter}
            >
              <input 
                ref={fileInputRef}
                type="file" 
                multiple
                accept="image/*" 
                onChange={handleFileUpload}
                className="file-input"
                id="file-upload"
              />
              <label htmlFor="file-upload" className="upload-label">
                <div className="upload-icon">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                    <polyline points="7,10 12,15 17,10"/>
                    <line x1="12" y1="15" x2="12" y2="3"/>
                  </svg>
                </div>
                <div className="upload-placeholder">
                  Cliquez ou d√©posez vos photos ici
                </div>
              </label>
            </div>

            {uploadedFiles.length > 0 && (
              <div className="uploaded-files">
                <h3 className="uploaded-files-title">Photos s√©lectionn√©es</h3>
                <div className="uploaded-files-grid">
                  {uploadedFiles.map((file, index) => (
                    <div key={index} className="uploaded-file-item">
                      <img
                        src={URL.createObjectURL(file)}
                        alt={file.name}
                        className="uploaded-file-preview"
                        onError={(e) => {
                          // Fallback si l'image ne charge pas
                          e.currentTarget.src = "https://images.unsplash.com/photo-1519741497674-611481863552?w=400&h=300&fit=crop";
                        }}
                      />
                      <div className="uploaded-file-name">{file.name}</div>
                      <button 
                        onClick={() => removeUploadedFile(index)}
                        className="remove-file-button"
                      >
                        √ó
                      </button>
                    </div>
                  ))}
                </div>
                <div className="upload-actions">
                  <button
                    onClick={handleUploadSubmit}
                    disabled={isUploading}
                    className="upload-submit-button"
                  >
                    {isUploading ? 'Ajout en cours...' : 'Ajouter √† la galerie'}
                  </button>
                </div>
              </div>
            )}
          </div>
        </main>
      </div>
    );
  }

  // Page de connexion
  if (currentView === 'login') {
    return (
      <div className="login-page">
        <div className="login-container">
          <button onClick={goToUpload} className="close-button">
            √ó
          </button>
          
          {!showPasswordChange ? (
            <>
              <h1 className="login-title">Galerie Priv√©e</h1>
              <p className="login-subtitle">Code d'acc√®s des mari√©s</p>
              
              {error && <div className="error-message">{error}</div>}
              
              <form onSubmit={handleLogin}>
                <div className="form-group">
                  <label htmlFor="password" className="form-label">
                    Code d'acc√®s
                  </label>
                  <input
                    type="password"
                    id="password"
                    value={password}
                    onChange={(e) => setPassword(e.target.value)}
                    className="form-input"
                    placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢"
                    required
                  />
                </div>
                
                <button type="submit" className="login-button">
                  Acc√©der √† la galerie
                </button>
              </form>
              
              <div className="password-change-section">
                <button 
                  onClick={() => setShowPasswordChange(true)}
                  className="password-change-button"
                >
                  Modifier le mot de passe
                </button>
                <p className="password-change-hint">
                  Seuls les mari√©s peuvent modifier le mot de passe
                </p>
              </div>
            </>
          ) : (
            <>
              <div className="password-change-title">Modifier le mot de passe</div>
              <form onSubmit={handlePasswordChange}>
                <div className="form-group">
                  <label htmlFor="currentPassword" className="form-label">
                    Mot de passe actuel
                  </label>
                  <input
                    type="password"
                    id="currentPassword"
                    value={currentPassword}
                    onChange={(e) => setCurrentPassword(e.target.value)}
                    className="form-input"
                    placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢"
                    required
                  />
                </div>
                
                <div className="form-group">
                  <label htmlFor="newPassword" className="form-label">
                    Nouveau mot de passe
                  </label>
                  <input
                    type="password"
                    id="newPassword"
                    value={newPassword}
                    onChange={(e) => setNewPassword(e.target.value)}
                    className="form-input"
                    placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢"
                    required
                  />
                </div>
                
                <div className="form-group">
                  <label htmlFor="confirmPassword" className="form-label">
                    Confirmer le mot de passe
                  </label>
                  <input
                    type="password"
                    id="confirmPassword"
                    value={confirmPassword}
                    onChange={(e) => setConfirmPassword(e.target.value)}
                    className="form-input"
                    placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢"
                    required
                  />
                </div>
                
                <div className="password-change-actions">
                  <button type="submit" className="login-button">
                    Modifier
                  </button>
                  <button 
                    type="button" 
                    onClick={() => {
                      setShowPasswordChange(false);
                      setCurrentPassword('');
                      setNewPassword('');
                      setConfirmPassword('');
                    }}
                    className="cancel-button"
                  >
                    Annuler
                  </button>
                </div>
              </form>
            </>
          )}
        </div>
      </div>
    );
  }

  // Galerie (seulement si authentifi√©)
  if (currentView === 'gallery' && isAuthenticated) {
    return (
      <div className="gallery-page">
        <header className="gallery-header">
          <h1 className="gallery-title">Notre Galerie Priv√©e</h1>
          <div className="gallery-header-actions">
            {isRefreshing && (
              <div className="refresh-indicator">
                <div className="refresh-spinner"></div>
                <span>Actualisation...</span>
              </div>
            )}
          <button onClick={handleLogout} className="logout-button">
            Se d√©connecter
          </button>
          </div>
        </header>

        <main className="gallery-main">
          {(() => {
            console.log('√âtat loading:', loading, 'Nombre de photos:', photos.length);
            return null;
          })()}
          {loading ? (
            <div className="loading-container">
              <div className="loading-spinner"></div>
              <p>Chargement de la galerie...</p>
            </div>
          ) : (
          <div className="gallery-grid">
              {(() => {
                console.log('Affichage de', photos.length, 'photos:', photos);
                return null;
              })()}
              {photos.length === 0 ? (
                <div className="empty-gallery">
                  <p>Aucune photo dans la galerie</p>
                  <button 
                    onClick={() => setCurrentView('upload')} 
                    className="add-photos-button"
                  >
                    Ajouter des photos
                  </button>
                </div>
              ) : (
                photos.map(photo => (
                  <PhotoCard 
                    key={photo.id} 
                    photo={photo} 
                    onZoom={handleZoom}
                    onDelete={handleDelete}
                    onToggleFavorite={handleToggleFavorite}
                  />
                ))
              )}
            </div>
          )}
        </main>

        {zoomPhoto && (
          <div className="lightbox" onClick={handleCloseZoom}>
            <img src={zoomPhoto.url} alt={zoomPhoto.title} className="lightbox-img" />
            <button onClick={handleCloseZoom} className="lightbox-close">
              √ó
            </button>
          </div>
        )}

        {notification && (
          <div className={`notification ${notification.type}`}>
            {notification.message}
          </div>
        )}
      </div>
    );
  }

  // Fallback - retour √† la page d'upload
  return (
    <div className="upload-page">
      <header className="main-header">
        <div className="main-header-content">
          <button onClick={goToLogin} className="main-connection-button">
            Connection
          </button>
        </div>
      </header>
      <main className="main-content">
        <div className="names-section">
          <div className="names-container">
            <h1 className="upload-title">Jean-Philippe</h1>
            <h1 className="upload-title">&</h1>
            <h1 className="upload-title">Lydie</h1>
          </div>
          <div className="separator"></div>
          <div className="thank-you-message">
            <p>Merci de partager votre tendresse et vos souvenirs pr√©cieux avec nous !</p>
          </div>
        </div>
      </main>
    </div>
  );
}

export default App;
